Roteiro Apresentacao (uso pessoal)
- Objetivo/visao: fila distribuida com lider, eleicao Bully, exclusao mutua Ricart-Agrawala, relogio logico Lamport, sincronismo fisico Cristian, replicacao via 2PC, roteamento/caixa de correio e retries TCP (arquivos-chave: src/node/node.py, src/algorithms/*.py, src/common/*.py).
- Topologia e transporte: nos TCP asyncio trocando envelopes JSON (src/common/messages.py); retries com backoff em src/node/transport.py; persistencia em disco data/tasks_<id>.json.
- Algoritmos:
  - Bully: ID maior vence; timeouts disparam auto-eleicao (src/algorithms/bully.py).
  - Lamport: incrementa/atualiza em cada mensagem (src/common/lamport_clock.py).
  - Ricart-Agrawala: REQUEST/REPLY/RELEASE para secao critica de fila/2PC (src/algorithms/ricart_agrawala.py).
  - Cristian: seguidores pedem TIME_REQUEST ao lider para offset local (src/node/node.py:_time_sync_loop).
- Replicacao e consistencia: 2PC no lider antes do ACK ao cliente (_on_enqueue, _two_phase_replicate, _on_repl_prepare/commit/abort em src/node/node.py); quorum = maioria; prepared expira se nao houver commit; re-sync de seguidores via SYNC_REQUEST/STATE apos perda de mensagens.
- Entrega e confiabilidade:
  - Dequeue marca owner e agenda requeue se faltar ACK (_on_dequeue, _requeue_task).
  - Roteamento P2P com TTL e mailbox para entrega indireta (_on_route, _on_mailbox_push, _deliver_mailbox).
  - Heartbeat + monitor para detectar lider ausente e iniciar Bully; seguidores limpam prepares ao trocar lider (src/node/state.py:set_leader).
- Clientes e interface: produtor src/clients/enqueue_client.py envia ENQUEUE/aguarda ENQUEUE_ACK; consumidor src/clients/worker_client.py recebe TASK e envia TASK_ACK; ambos suportam peers seeds para tolerar troca de lider.
- Script e configuracao: run-local.ps1 -Nodes 3 orquestra cluster local; NodeConfig/PeerConfig em src/common/config.py.
- Testes relevantes (dizer que ja existem e o que cobrem):
  - tests/integration/test_distributed_system.py: eleicao + replicacao 2PC + quorum; sync de follower que retorna; reentrega sem ACK.
  - tests/unit/test_lamport_clock.py, tests/unit/test_algorithms.py, tests/unit/test_node_state.py cobrem componentes de base.
- Benchmark: python scripts/bench.py --messages 60 --concurrency 15 gera throughput/latencia; numeros atuais no README.md (14 msg/s ~0.9s avg no cenario 60x15).
- Demonstracao passo a passo (fazer ao vivo):
  1) Subir cluster: .\run-local.ps1 -Nodes 3 (mostre portas/IDs nos logs Rich). Se bloquear: Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass.
  2) Enfileirar: python -m src.clients.enqueue_client --id 9000 --payload "hello world" (mostrar ACK).
  3) Consumir: python -m src.clients.worker_client --id 9001 (mostrar payload e ACK enviado).
  4) Falha de lider: derrubar processo com maior ID; aguardar Bully (logs LEADER_ANNOUNCE/leader_timeout) e repetir enqueue/dequeue.
  5) Persistencia/recuperacao: Ctrl+C nos 3 nos, abrir data/tasks_<id>.json e mostrar tarefa com ack. Subir de novo (.\run-local.ps1 -Nodes 3) e apontar o log tasks_recovered.
  6) Reentrega sem ACK: rodar worker, matar antes do ACK (Ctrl+C). Esperar timeout e mostrar task_requeued no lider. Rodar worker de novo e mostrar mesma task entregue.
  7) Follower retorna e sincroniza: parar (opcional limpar: Remove-Item data\tasks_*.json -Force). Subir 3 nos, derrubar seguidor (porta 8001). Fazer enqueue enquanto ele esta fora: python -m src.clients.enqueue_client --id 9000 --payload "fora-do-ar". Subir seguidor manual: python -m src.node.main --id 2 --host 127.0.0.1 --port 8001 --peers 127.0.0.1:8000:1,127.0.0.1:8002:3. Mostrar log SYNC_REQUEST/STATE ou data/tasks_2.json com a tarefa.
  8) Opcional bench rapido: python scripts/bench.py --messages 10 --concurrency 3 (mostra throughput/latencia).
  9) Opcional roteamento/mailbox: parar lider, enviar producer para follower: python -m src.clients.enqueue_client --id 9000 --host 127.0.0.1 --port 8001 --payload "via-follower". Subir lider e mostrar entrega/ACK (MAILBOX_DELIVER).
- Slides/gancho de fala (ordem): problema -> arquitetura/algoritmos -> fluxo ENQUEUE->2PC->ACK -> tolerancia a falhas (eleicao, quorum, reentrega, sync) -> demonstracao -> resultados de benchmark -> limitacoes (pode perder commit se quorum cai no meio do 2PC; estado em JSON simples; sem autenticacao).
